### java和python区别

- 技术特点不同
  - java源自C++和C的技术体系，拥有跨平台，面向对象等特点
  - python属于解释性脚本语言，其在设计上清晰划一的风格，使得python语言易读易维护。
- 应用领域不同：
  - java主要是用于安卓应用，网站后台等开发
  - python主要用于科学计算，人工智能，数据分析等领域
- python的变量是动态的，java的变量是静态的
- python虚拟机没有java 的优秀

### 从 URL 输入到页面展现到底发生什么？

- DNS 解析:将域名解析成 IP 地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 断开连接：TCP 四次挥手

### object类中的常用方法的用处：

1、 getClass()：获取类的class对象。
2、 hashCode:获取对象的hashCode值
3、 equals():比较对象是否相等，比较的是值和地址，子类可重写以自定义。
4、 clone()：克隆方法。
5、 toString():如果没有重写，应用对象将打印的是地址值。
6、 notify():随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。
7、 notifyall():解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。
8、 wait():导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒。该方法只能在同步方法中调用。如果当前线程不是锁的持有者，该方法抛出一个IllegalMonitorStateException异常。
9、 finalize()：对象回收时调用

### SpringIOC和SpringAOP（谈一下你对于Spring的理解）

#### IOC解析

IoC（Inverse of Control:控制反转）是一种**设计思想**，就是 将**原本在程序中手动创建对象的控制权，交由Spring框架来管理**。 IoC 在其他语言中也有应用，并非 Spirng 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。

将**对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入**。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。

Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。

#### AOP解析

AOP(Aspect-Oriented Programming:**面向切面编程)** 能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，**便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。**

Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理。

使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 

### 面试题:#{}和${}的区别是什么？

- {}是编译预处理**（预编译的机制。预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。）**，${}是字符串替换
- Mybatis在处理#{}号时，#{}传入的参数是以字符串传入，会将SQL中的#{}替换为？,调用PreparedStatement的set方法来赋值；MyBatis在处理 {} 时，就是把${} 替换成变量的值，相当于statement编译。
- 使用#{}可以有效防止SQL注入，提高系统的安全性；${}不能。
- \#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外

### 你的学习方式有哪些

官网+书籍+B站+CSDN+博客园

### 拦截器和过滤器区别

**过滤器**（Filter）
过滤器，是在java web中将你传入的request、response提前过滤掉一些信息，或者提前设置一些参数。然后再传入Servlet或Struts2的 action进行业务逻辑处理。比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉），或者在传入Servlet或Struts2的action前统一设置字符集，或者去除掉一些非法字符。

**拦截器**（Interceptor）
拦截器，是面向切面编程（AOP，Aspect Oriented Program）的。就是在你的Service或者一个方法前调用一个方法，或者在方法后调用一个方法。比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。

通俗理解：
（1）过滤器（Filter）：当你有一堆东西的时候，你只希望选择符合你要求的某一些东西。定义这些要求的工具，就是过滤器。（理解：就是一堆字母中取一个B）
（2）拦截器（Interceptor）：在一个流程正在进行的时候，你希望干预它的进展，甚至终止它进行，这是拦截器做的事情。（理解：就是一堆字母中，干预它，通过验证的少点，顺便干点别的东西）

**二、拦截器与过滤器的区别**
区别：
①：拦截器是基于java的反射机制的，而过滤器是基于函数的回调。
②：拦截器不依赖于servlet容器，而过滤器依赖于servlet容器。
③：拦截器只对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
④：拦截器可以访问action上下文、值、栈里面的对象，而过滤器不可以。
⑤：在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。
⑥：拦截器可以获取IOC容器中的各个bean，而过滤器不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。

**三、拦截器与过滤器的触发时机**
拦截器与过滤器触发时机不一样
过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。

过滤器包裹servlet，servlet包裹住拦截器

### Java 的锁都有哪些

- 公平锁和非公平锁
  - 公平锁：多个线程按照申请锁的顺序来获取锁
  - 非公平锁：多个线程不是按照申请锁的顺序来获取锁。
- 可重入锁
  - 某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。
- 独享锁和共享锁
  - 独享锁：该锁一次只能被一个线程所持有。例如ReentrantLock和synchronized都是独享锁
  - 共享锁是指该锁可被多个线程所持有。例如ReadWriteLock中的读锁是共享锁
- 互斥锁和读写锁
  - 互斥锁在Java中的具体实现就是`ReentrantLock`
    读写锁在Java中的具体实现就是`ReadWriteLock`
- 乐观锁和悲观锁
  - 二者不是Java锁的类型而是，看待并发的角度
  - 悲观锁认为：对于同一个数据的访问，必然会造成数据的修改，哪怕没有修改，也会认为修改，所以每次都会加锁
  - 乐观锁认为。对于同一个数据的访问，不会修改数据，适合读操作
- 分段锁
  - 分段锁其实不是锁，而是一种锁的设计，对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
- 偏向锁、轻量级锁和重量级锁
  - 这三种也是锁的设计，并且是针对synchronized的，在Java5中通过引入锁升级实现高效，synchronized的，这三种锁的状态通过**对象监视器**在对象头中的字段表明的。
  - 偏向锁：指的是一段同步代码一直被同一个线程访问，那么该线程会自动获取锁，降低获取锁得代价。
  - 轻量级锁：当锁是轻量级锁，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他的线程就会通过自旋的方式获取锁，不会堵塞，提高性能。
  - 重量级锁：当锁是轻量级锁的时候，另一个线程虽然是自旋，但是不会一直自旋，当自旋到一定程度，还没有获得锁，就会放弃，进入堵塞。此时锁升级为重量级锁。
- 自旋锁
  - 指的是想要获取锁的线程不会马上进入堵塞，而是采用循环的方式尝试获取锁，这样就减少了上下文的切换。



## 秋招

### 京东一面

**@Transolational是否可以在private方法上面使用**

Java 开发中，在使用注解时，一不小心把注解写到了 private方法上，编译既不报错也不会有任何提示，默认忽略，实际功能却不会生效。原因在于，spring AOP无法实现或者继承private方法，本质原因。

**spring注解的生效机制**

Spring的注解主要时分为两类：

- 一类是添加到类上面，@Component@Service@Reporisty
- 一类是添加到方法和字段上面

Spring对于注解的支持都是通过反射获得相应的注解，来做相应的处理。

*注解的实现*

- 接口使用@interface定义
- 通过继承以下注解实现功能
  - @Target 表示注解用于什么地方：类、方法、字段、接口等等。
  - @Retention表示注解的级别：比如编译之后被弃用，运行时期一直有用
  - @Documented此注解包含在javadoc中
  - inherited允许子类继承父类的注解

*以Spring的Controller为例*

Controller类使用继承了@Component注解的方法，将其以单例的形式传入spring容器，然后spring容器会通过扫描进行以下操作

1. 使用asm技术扫描.class文件，并将包含@Component及元注解为@Component的注解@Controller、@Service、@Repository或者其他自定义的bean注册到beanFactory中
2. 然后spring在注册处理器
3. 实例化处理器，然后将其放到beanPostFactory中，然后我们就可以在类中使用了
4. 创建bean时，会自动调用相应的处理器。

### 数据结构大致包含以下几种存储结构：

- [线性表](http://data.biancheng.net/view/157.html)，还可细分为[顺序表](http://data.biancheng.net/view/158.html)、[链表](http://data.biancheng.net/view/160.html)、[栈](http://data.biancheng.net/view/169.html)和[队列](http://data.biancheng.net/view/172.html)；
- [树](http://data.biancheng.net/view/23.html)结构，包括普通树，[二叉树](http://data.biancheng.net/view/192.html)，线索二叉树等；
- [图](http://data.biancheng.net/view/200.html)存储结构；

　1. 贵公司一向以XXX著称，能不能说明一下公司这方面的特点？
　　2. 贵公司XXX业务发展很好，这是公司发展的重点么？
　　3. 对技术和业务怎么看？
　　4. 贵公司一般的团队是多大，几个人负责一个产品或者业务？
　　5. 贵公司的开发中是否会使用到一些最新技术？
　　6. 对新人有没有什么培训，会不会安排导师？
　　7. 对Full Stack怎么看？
　　8. 你觉得我有哪些需要提高的地方？

### Object的8大方法

- clone
- hashcode
- equals
- finalize
- notify
- notifyAll
- wait
- getClass
