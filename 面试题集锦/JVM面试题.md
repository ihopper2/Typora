1.JVM对于java

文件的加载过程

加载：将class文件导入到JVM中，将里面的静态存储结构转换为运行时数据区里面方法区的结构

验证：验证class文件是否符合JVM规范

准备：对于class文件中的静态变量赋予默认初始值

解析:将常量池中的符号引用转化为直接引用

初始化：执行类构造器，为静态变量和静态代码块赋值

双亲委派机制：

PC寄存器：用于存储指向下一条指令的地址

虚拟机栈：没有垃圾回收，有内存溢出，栈帧操作（局部变量表，操作数栈，动态链接，方法返回地址）

- 局部变量表：底层是一个数组，用于存储8中基本类型，对象应用，返回地址，在编译前就确定了大小，重复利用
- 操作数栈：用于临时存储中间结果
- 动态链接：指向常量池中的该栈帧所属方法引用
- 方法返回地址：用于存放调用该方法的PC寄存器的值

本地方法栈：本地方法接口，本地方法，fenJava方法，用起来很方便，便于Java与外界交互

方法区：永久代（jdk7及以前）元空间（jdk8）

jdk7以前：永久代包含运行时常量池，类信息，方法信息，域信息，常量信息，字符串常量池，静态变量都在JVM中

jdk7：永久代包含运行时常量池，类信息，方法信息，域信息，常量信息，而字符串常量池，静态变量都放到了堆中。

jdk8，方法区改名为元空间，放到了内存中，就只有运行时常量池，类信息，方法信息，域信息，常量信息，而字符串常量池，静态变量都放到了堆中。

如何判断垃圾：引用计数器法（Java中没用，互相引用的问题），可达性分析算法。

垃圾回收算法：copy mark-sweep mark-compact

| serial       | 串行运行 | 新生代        | 复制算法      | 响应速度优先 |
| ------------ | -------- | ------------- | ------------- | ------------ |
| parnew       | 并行运行 | 新生代        | 复制算法      | 响应速度优先 |
| paralled     | 并行运行 | 新生代        | 复制算法      | 吞吐量优先   |
| serial old   | 串行运行 | 老年代        | 标记压缩      | 响应速度优先 |
| paralled old | 并行运行 | 老年代        | 标记压缩      | 吞吐量优先   |
| cms          | 并行运行 | 老年代        | 标记清除      | 响应速度优先 |
| G1           | 并发执行 | 新生代+老年代 | 标记压缩+复制 | 响应速度优先 |

## 1.类加载子系统

### 1.1 类加载器分类

分为引导类加载器和自定义加载器，BootstrapClassLoader，ExtensionClassLoader，SystemClassLoader，自定义类加载器

这四者不是上下级关系而是包含关系

> BootstrapClassLoader引导类加载器，用c++语言写的用于加载核心类库，包名为，java，javax

> SystemClassLLoader系统类加载器，用于加载环境变量或者系统属性

> ExtensionClassLoder扩展类加载器，

引导类加载器-->扩展类加载器-->系统类加载器-->自定义类加载器

### 1.2 双亲委派机制

如果一个类加载器收到了类加载请求，他不会自己去加载，而是把这个请求委托给父类执行，如果父类加载器还有父类，则依次向上委托，请求最终到达了顶层的启动类加载器。如果父类可以完成类加载任务，就成功返回；否则子加载器才会自己尝试去添加。

> 优势:避免了重复加载，保护程序的安全性，防止核心API被随意更改。
