<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20220117202705516.png" alt="image-20220117202705516" style="zoom:25%;" />

在介绍寻址方式之前，先提一个问题，供大家在学习过程当中进行思考，为什么在指令当中要设置多种类型的寻址方式？好，下面我们开始讲课，首先看寻址方式，所谓寻址方式呢，就是指。确定本条指令，它的操作数的地址，或者是下一条要执行的指令的地址。所以，所谓寻址方式就是如何找到指令或者是数据的地址。从指令或者数据这个角度，我们可以把寻址方式划分成两类。第一类就是指令的寻址，第二类是在指令当中数据的寻址。

<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20220117203446576.png" alt="image-20220117203446576" style="zoom:25%;" />

我们首先介绍指令的寻址，指令的寻址呢，主要有两种方式，第一种方式呢，就是顺序寻址，所谓顺序寻址，就是指取完一条指令之后，顺序的去下一条指令。由于指令的地址是保存在PC当中，那么取完当前的指令，为了取下一条指令，就要把PC的内容加上一，然后送到PC当中。那这里有一个问题，就是这个加1是不是在任何一台计算机当中，或者是任何一个指定机当中都是PC加1，实际上并不是这样，这个1是比较复杂，如果内存单元它的编制单位是字节的，每一条指令它的长度是32位，也就是四个字节，那么顺序寻址的时候，每次加的值就是四，如果指令的长度是64个字节，那么PC加上8，那么如果指令是可变长度的，那么这个加这个1会更加复杂。第二种方式就是跳跃寻址，由转移指令指出下一条指令的地址，我们可以看一下下面这个例子，这是程序由多条指令构成。假设我们指令的地址是从0开始，那么在开始执行这个程序的时候，PC的值被置成了0，把这条LDA指令取出来。这是一个取数值，这条指令取出以后，PC会自动加1为取下一条指令做准备，那么，从第一条指令到得到第二条指令的地址，那这个寻指就是顺序寻址。同样，下面这条指令也是顺序寻址地址。地址为3的这条指令为无条件跳转指令，它的目标地址是七，那么执行完这条指令之后，要找到下一条指令的地址，那么采用的寻址方式就是跳跃寻址，跳到七取出STA指令，那么STA指令，下一条地址依然是顺序寻址，那这是指令寻址常用的两种方式，

<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20220117204120966.png" alt="image-20220117204120966" style="zoom:25%;" />

那么第二呢，我们来介绍数据寻址，数据寻址，寻址方式比较多，也比较复杂，我们先给出指令的格式，假如说我们现在的这个指令是一个单地址的指令，并且在地址的前面，我们专门给出一个字段来表示寻址特征，用它来标识，采用什么样的一种寻址方式，能够找到操作数所在地址，同样操作码还是指要做什么样的操作，这个地址字段给出的名称我们叫做**形式地址**，所谓形式地址就是我们在指定当中使用到的地址，那么形式地址并不是我们要找到的那个数据所在的存储单元，或者是寄存器真实地址，那么要找到真实地址，我们要利用寻址方式和形式地址进行一定的运算或者是转换才能得到真正的有效的这个地址，那么所以有效地址就是指操作数的真实地址。为了讲解的方便我们做如下约定，假设指令字长=存储字长=机器字长，这样的话可以简化我们的例子，使我们讲解过程更容易理解。下面呢，我们介绍第一种数据寻址方式，就是立即数寻址，所谓立即数寻址。或者是立即寻址，那么形式地址部分给出来的直接就是操作数，这个数据直接参与操作码指定的运算，那么如果我们采用立即寻址方式的话，那么我们上面的指令的格式就变成了这种格式，其中这个#就是立即寻址的特征。在译码的过程中如果发现寻址特征位是这个#的话，那么他表示后面的操作数是一个立即数，这个立即数呢，可以是正数，可以是负数，我们用补码的形式来进行表示，如果采用立即数寻址的话，操作数在取指令的过程当中。实际上已经被取入到了cpu当中，所以呢，在指定的执行过程当中，不需要再一次的放存，指令执行阶段不需要放存，那么A到底取多长，或者A要占多少位二进制位比较合适这个，要通过实验才能得出结果。那这是第一种方式，叫做立即寻址。

<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20220117204705653.png" alt="image-20220117204705653" style="zoom:25%;" />

第二种方式叫做直接寻址，所谓直接寻址就是指**有效地址就等于形式地址**，那么，A给出来的就是操作数所在的内存单元的地址，由形式地址直接给出。比如说我们下面这条指令，这是一条LDA的指令，它是指把内存单元当中的数据取到cpu当中，把它保存在ACC这个寄存器，这是在我们模型机当中的规定，并不是所有的机器都是这样的，还是希望大家在学习的过程当中不要学俗。投影上这个蓝色的部分，我们投影上这个蓝色的部分就是寻址特征，它表示后面的这个操作数，我们采用的是直接寻址方式，直接给出的就是内存单元的物理地址，这样的话，我们利用这个内存单元的地址去访问内存，从这个单元当中把操作数取出。完成操作码部分给定的操作，把操作数送到ACC这个寄存器当中去，那我们就完成了，直接寻址这样的一个指令的操作，这样的指令在执行过程当中需要访问一次存储器，当然这是我们对指令格式的假设，我们这指令格式当中，那么只有一个地址码字段。a的位数就决定了他的寻址范围，如果a过短的话，那么寻址范围非常小，那么这种方式呢？地址码字段非常难以修改，那么编程也比较难，比如说我们要对一个数组的数据，每一个数据都要加1，用循环的方式来做，那么这条指令就很难去实现，除非我们有另外一条指令。那条指令呢？能够把我们LDA的那条指令，从内存当中取出，并且能够修改地址码部分，那么我们才可以用循环程序的方式来完成，我们需要的操作。那这是第二种寻址方式，叫做直接寻址。

<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20220117205432242.png" alt="image-20220117205432242" style="zoom:25%;" />

第三种方式，隐含寻址，所谓隐含是指我们把寻址方式给它隐藏到操作码当中。或者是参与运算的某一个数据，它所在的位置由操作码直接列出。我们看下面这条指令，这个蓝色的部分仍然是寻址特征，但是它的寻址特征是指后面的这个地址码它的寻址方式，实际上这条指令是加法，需要两个操作数参与运算。并且呢，要把加法的结构进行保存，那么内存单元给出了其中的一个操作数，或者指令当中给出了其中的一个操作数，另外的一个操作数，我们采用的就是隐含寻址的方式，这个操作数呢，它隐含在ACC当中，因此它的操作，我们现在假设这个寻址特征位给出的是一个直接寻址，也就是说地址码部分我们采用直接寻址的方式。由这个地址直接到给定的内存单元当中取出参加加法操作的一个操作数，另外的一个操作数是保存在了ACC当中，所以ABC当中的这个数据和我们内存当中的数据做加法操作。ALU是一个组合电路计算出的结果放在一个暂存器当中，然后再把这个结果送入到ACC，那么这条指令的执行才会结束。尽管我们是两个操作数参与预算，但是其中的一个操作数，它所在的地址我们用隐含的方式给出，所以呢，在指令当中，我们只需要给出一个操作数的地址就可以了，这样的话减少了一个地址码字段，可以缩短指令的长度，这是第三种寻址方式，隐含寻址。

<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20220117210728775.png" alt="image-20220117210728775" style="zoom:25%;" />

间接寻址就是指操作数的地址保存在某一个内存单元当中，指令当中出现的是这个内存单元的地址，有效地址是这个在给定的内存单元当中进行保存。我们看下面的例子，假如说我们指令是这种形式，那么蓝色的部分依然是寻址特征，这个寻址特征它标示了我们后面的操作数，采用的方式是间接寻址，那么间接寻址也有两种形式，一种形式是一次间址，我们看一次间址是怎么操作的，这条指令它真正的操作数所在的地址是保存在这个内存单元当中，要想取得这个操作数的话，我们首先要找到这个操作数，它保存的地址，那么，有效地址就保存在地址为A的这个单元当中，然后呢，我们利用这个有效地址再一次访问内存得到的才是真正的操作数。很显然，在执行指令阶段，我们要访问两次内存，一次访问内存是取出有效地址，第二次访问内存是在有效地址当中获取操作数，那么利用这种方式我们可以扩大寻址范围。尽管a的字段可能会比较短，寻址范围比较小，但是呢，我们可以把ea的一个字段放的很长，可扩大寻址范围。另外呢，非常方便编程，我们可以通过修改这个ea来修改真正的操作数所在的地址，这样的话，指令当中的形式地址不需要任何变化，那么操作数的真正地址就会发生变化，非常便于编写程序，那么还可以进行多次间址，如果我们采用多次间址的话，假如指令还是这种格式，那么上面是我们的寻址特征，A并不是操作数的地址，它是指包含了或者是能够找到操作数，那么这个地址我们必须要经过的中间过程的地址，我们看一下多次间址它的操作过程，那么这是内存单元。我们根据A找到了一个内存地址，这个地址当中包含了一个数据，这个数据呢，现在并不是我们要的那个操作数的地址，前面有一个标识啊，就是这个1，它是指目前这个地址依然是一个间接地址，或者依然是一个间址寻址方式，那么我们呢，还要再一次的进行寻址，那么可能需要多次这样的一个过程，那么一直到这个标志到0为止，这个单元当中保存的才是有效地址，我们利用这个有效地址还要再一次的进行访存，把操作数从内存单元当中取出，然后参与指定操作，那么这就是间接寻址需要多次访存。

<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20220117212444278.png" alt="image-20220117212444278" style="zoom:25%;" />

然后呢，我们看第五种寻址方式寄存器寻址，他的有效地址就是寄存器的编号。我们看一下一个例子，假如说指令的格式如我们投影所示，地址码部分给出来的是寄存器的编号，当然这个值如果没有寻址特征的话，那么计算机并不知道。这是一个立即数还是一个寄存器的编码或者其他的东西，所以要由这个寻址特征指出这个操作数呢？它的寻址方式是寄存器寻址，Ri是一个编号，因为当前这条指令或者这个操作数，它采用的是寄存器寻址方式，参加运算的数据是保存在给定的编号的寄存器当中，cpu要在给定的寄存器当中把操作数取出进行相应的操作。从这儿可以看出，在执行阶段不需要访存，因为操作数是保存在寄存器当中，寄存器在cpu的内部访问速度非常快。另外呢，寄存器的个数非常有限，比如说只有16个寄存器，那么对寄存器领编码的话有四位就足够，可以缩短指令长度，这是寄存器寻址。

### 寄存器间接寻址

寄存器间接寻址也是指定寄存器编号，但是寄存器内存放的并不是操作数，而是操作数的有效地址。
有效地址在寄存器中，操作数在存储器中，执行阶段访存，但访存比间接寻址少一次，便于编制循环程序

<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/20201120154558623.png" alt="img" style="zoom: 50%;" />

### 基址寻址

基址寻址需要有基址寄存器BR，操作数的有效地址等于形式地址加上基址寄存器中的内容（基地址）。

基址寄存器分为隐式和显式。隐式是指计算机内设有一个专门的，用户不必明显指出该基址寄存器，只需由寻址特征位反应基址寻址就可以。而显式是在一组通用寄存器内由用户指定一个基址寄存器存放基地址。

基址寻址中的BR由系统或者管理程序根据主存的使用情况分配初始值，便可将用户程序的逻辑地址转化为主存的物理地址（实际地址）。

<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/20201120155708310.png" alt="img" style="zoom:50%;" />

### 变址寻址

变址寻址与基址寻址极为相似，有效地址等于指令字中的形式地址与变址寄存器IX的内容相加 。

基址寻址主要用于为程序或数据分配内存空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值是不可变的，而指令字中的形式地址A是可变的，在变址寻址中，变址寄存器的内容是用户设定的，在程序执行过程中其值可变，而指令字中的A是不可变的。

变址寻址主要用于处理数组问题，在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器的IX内的内容，便可以得到数组中任一数据中的地址，特别适合编制循环程序。

<img src="https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/20201120203755583.png" alt="img" style="zoom:33%;" />

### 相对寻址

相对寻址的有效地址是将程序计数器PC内容与指令字中形式地址A相加而成。

如图可见，操作数的位置与当前指令的位置有一段距离A。

相对寻址最大的特点就是转移地址不固定，他随PC值的变化而变化，因此，无论主程序在哪段区域，都可正常运行，对编写浮动程序特别有利。

![img](https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/20201121154707989.png)







### 堆栈寻址

堆栈要求计算机中设有堆栈，可以用寄存器组，也可以主存的一部分空间来做堆栈。

栈只能从栈顶进行操作，堆栈也只能从一个口进行读写，操作数只能从栈顶地址指示的主存单元进行存或取。

SP始终指示着栈顶，所以不论是出栈还是进栈SP都需要发生变化。若栈底元素大于栈顶元素，则每次进栈SP=（SP）-△；每次出栈 SP=（SP）+△；

△的值与主存编址方式有关。若以字编址，△区1；以字节编址，则根据存储字长是几个字节才能确定

![img](https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/20201121160756671.png)

### 为什么讲解寻址方式

显然，在硬件和软件之间需要一座桥梁，而“计算机组成原理”就扮演了这样一个角色，它既隔**离了软件和硬件，**也提供了让软件无需关心硬件，就能直接操作硬件的接口。 也就是说，你只需要对硬件有原理性的理解，就可以信赖硬件的可靠性，安安心心用高级语言来写程序。



