## 1.计算机网络体系结构

### 1.1 网络协议是什么

在计算机网络要做到有条不紊的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式，是否需要一个应答信息。这些规则被称为网络协议。

### 1.2 1.2为什么要对网络协议分层

- 简化问题难度和复杂度，由于各层之间独立，我们可以分一个大问题为小问题
- 灵活性好。当其中的一层的技术变化时，只要层接口之间的关系保持不变，其他的层就不受到影响。
- 易于实现和维护。
- 促进标准化工作，分开后，每一层功能可以相对简单的描述。
- 但是协议分层的的缺点是，功能可能出现在多个层面，产生额外的开销

OSI七层协义：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

TCP/IP协义：应用层、传输层、网络层和物理+链路层。

![image-20210901141853942](https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20210901141853942.png)

## 2.TCP/IP协义

### 2.1 应用层

应用层是通过应用进程之间的交互完成特定的网络应用，应用层协议定义的进程之间的通信和交互规则。

对于不同的网络应用需要不同的应用层协义，如域名解析的DNS，支持万维网的http，邮件转发的SMTP等协议。

### 2.2 传输层

传输层主要是为两台进程之间的通信提供数据传输服务，应用进程利用该服务传送应用层保文。

传输层主要是用到两种协议：

- 传输控制协议-TCP：提供面向连接的，可靠的服务。
- 用户数据协义-UDP：提供面向无连接的，不可靠的服务。

![image-20210901142939979](https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20210901142939979.png)

每一个应用层都会使用到两个传输层协议中的一个：

- 运行在tcp上的协议：
  - http协议，用于普通浏览
  - https协议，http的安全版本
  - FTP协议。用于文件传输
  - SMTP，用于收发邮件
  - SSH，用于安全远程登录
- 运行在udp上的协议：
  - NTP,网络同步
  - DHCP，动态配置ip地址
- dns可以运行在两个协议上面

### 2.3 网络层

网络层是选择合适的网间路由和交换节点，确保计算机的数据及时传送。

### 2.4 数据链路层

两台主机之间的数据传输总是在一段一段的链路上传输的，因此需要专门的链路层协议。在两个相邻的节点之间传输数据，数据链路层将从网络层交换下来的IP数据封装成帧，再两个相邻的链路层节点上传递。

### 2.5 物理层

在两个物理层上传输的数据单位为比特，物理层的作用是实行相邻计算机节点之间比特流的透明传输。

![image-20210901151713007](https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20210901151713007.png)

## 3.TCP的三次握手和四次挥手

### 3.1 三次握手

三次握手的本质是确定通信双方有通信能力

![image-20210901151838704](https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20210901151838704.png)

- 第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。
- 第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。
- 第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。

### 3.2 四次挥手

四次挥手的目的是关闭连接

![image-20210901151929133](https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20210901151929133.png)

比如客户端初始化的序列号为ISA=100,服务端初始化的序列号ISA=300，TCP连接成功以后客户端一共发送了1000个字节的数据，服务端在而客户端发送FIN报文的时候前后总共回复了2000个字节的数据。

- 第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。
- 第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。
- 第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。
- 第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。

### 4.常见面试题

### 4.1 什么是HTTP，HTTP和HTTPS的区别是什么

HTTP是计算机世界中专门在两点之间传输文字，图像，视频的等超文本数据的约定和规范

![image-20210901152427763](https://kangrui-pictures.oss-cn-beijing.aliyuncs.com/img/image-20210901152427763.png)

### 4.2 常见的HTTP码

| 1**  | 信息，服务器收到请求信息，请继续           |
| ---- | ------------------------------------------ |
| 2**  | 成功，请求被成功接收和处理                 |
| 3**  | 重定向，需要进一步操作完成请求             |
| 4**  | 客户端错误，请求包含语法错误，无法完成请求 |
| 5**  | 服务端错误，服务器在处理请求过程中出现错误 |

### 4.3 get和post区别

谈论get和post请求之前，我们要说一下http协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议的两种方法。
HTTP协议种定义了四种浏览器和服务器进行交互的不同方法，基本方法就是四种，分别是GET,POST,PUT,DELETE这四种方法可以理解为对服务器的查改增删。

- GET:从服务器上获取数据也就是所谓的查，仅仅是获取服务器资源，不进行修改。

- POST:向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。

- PUT：英文含义是放置，也就是向服务器添加数据，就是所谓的增。

- DELETE:删除数据

**GET和POST区别：**

- GET是不安全的，因为在传输过程中，数据被放在请求的url中； post的所有操作对于用户来说都是不可见的。
-   GET请求提交的url的数据最多是2048字节，而post请求则没有大小限制。
-   GET限制From表单的数据值必须是ASCII字符，而POST则支持整个ISO10646字符集。
-   GET执行效率比POST好，GET是form提交的默认方法。
-   GET产生一个tcp包。而POST产生两个。

### 4.4 什么是对称加密和非对乘加密

对称密钥加密是指加密和解密使用同一个密钥方式，这种方法存在一个最大的问题就是密钥的发送问题。
非对称加密指的是使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但是私钥只有自己知道。可以保证安全性。

### 4.5 什么是HTTP2

HTTP2可以提高网页的性能。
在HTTP中浏览器限定了同一个域名下的请求数量一般是是6个，当很多资源在请求的时候，当队头达到了最大的请求数量的时候，剩下的资源要等当亲啊的6个请求结束之后才能进行。
HTTP2引入了多路复用技术，这个技术只需通过一个tcp请求就可以传输所有的请求数据。多路复用技术绕过了同一个域名下的请求数量的问题，提高了网页的性能。

### 4.6 Session、Cookie和Token的主要区别

HTTP本身是无状态的，即浏览器无法判断用户的身份。
**Cooike**
Cookie是服务器保存在浏览器上的小文件，包含用户的相关信息。客户端在向服务器发送请求的时候，如果服务器需要记录用户的状态，就会使用response向浏览器发送一个cookie，浏览器会把cookie保存起来，当浏览器再次访问该服务器时，浏览器会把网址和cookie一起发送给服务器，服务器检查该cookie，从而确定用户身份。
**Session**
session是以来cookie实现的，session服务器端的对象。
session是服务器和浏览器会话过程中，服务器分配的一块存储空间。服务器默认浏览器的cookie中包含sessionid，当浏览器请求服务器时，传输过来的cookie中包含sessionid，服务器根据sessionid，获取会话中存储信息，从而确定会话者的身份。
**cookie和session的区别**
存储位置和安全性：cookie存在浏览器中，session存储在服务器端，session的安全性要高于cookie。
存储空间：单个cookie的存储空间不能超过4k，很多浏览器限制一个站点最多保存20个cookie信息，而session无限制。
占用服务器资源：session一定时间内保存在服务器中，当访问增多，占用服务器性能，考虑到服务器性能，应该使用cookie。
**Token**
Token的引入：Token是用户端频繁的向客户端发送请求数据，服务器端需要频繁的去数据库查询用户名和密码以此来验证，给出相应的提示，在这样的背景下token应运而生。
Token:是服务器生成的一段字符串，作为客户端请求的一个令牌，，当第一次登陆时，服务器生成一个Token返还给客户端，以后客户端只需要带上这个token来请求数据即可，无需再次带上用户名和密码。
目的：减轻服务器端的压力，减少频繁的查询数据库，是服务器更加便捷。
Token是服务端产生的，如果前端使用用户名和密码向服务器端请求验证，那么服务器端就会返回给前端一个Token，前端可以子啊每次请求的时候带上这个Token就可以了。
**Token和Session的区别**
session机制的存在会加大服务器的压力，扩展性不强，而Token存储在客户端。
token提供身份认证功能，安全性要比session好。
session这种机制只是适合服务端和客户端代码存在于同一台机器上，token适用于前后台分离。

### 4.7 Servelt是线程安全吗

不是线程安全的，多线程读写会导致数据不同步的问题。
解决的方法就是不定义name属性，而是在doget和dopost方法内定义name变量，虽然可以使用synchronized（name）{}。但是会造成线程等待，不是很科学。

### 4.8 Servlet接口中有哪些方法及Servlet生命周期探秘

在javaWeb中，Servelt主要是负责接受用户的请求，HTTPServeltRequest，在doGet（）和doPost（）中做出相应的处理，并将回应HttpServeltResponse反馈给客户。Servlet可以设置初始化参数，共Servlet内部使用。
void init(ServletConfig config) throws ServletException
void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException
void destory()
java.lang.String getServletInfo()
ServletConfig getServletConfig()
**生命周期**
web容器加载Servlet并将其实例初始化以后，Servlet生命周期开始了
容器运用init()方法，进行Servlet初始化
请求到达时，调用Servlet的service()方法，servie()方法，会根据对应的请求调用doget或者dopost方法。
当服务器关闭时会调用destorty()方法。
init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行

### 4.9 如果客户端禁止 cookie 能实现 session 还能用吗？

Cookie和Session一般被认为是两个独立的东西，Session采用的在服务器端保持状态的方案，而cookie采用的是在客户端保持状态的东西。
但是禁用了cookie就得不到session，是因为Seesion使用sessionID来确定当前对话的是对象的，但是sessionID是存储在cookie中，禁用cookie相当于失去了SessionID，也就得不到了Seesion。
可以通过手写URL传值。

### 4.10 为什么是三次握手而不是两次握手

主要是为了防止已经失效的连接请求突然又传送到了服务器，从而产生错误。
如果使用两次握手连接，假设有这样一种场景，客户端发送了一个请求连接并且没有丢失，只是因为网络节点中滞留时间过长，由于TCP客户端迟迟没有收到确认报文，以为服务器没有收到，此时会重新发送该报文，此时服务器和客户端两次握手建立连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，网络通畅了达到了服务器，这个报文本该失效，但是两次握手导致客户端和服务器在此建立了连接，这将导致不必要的错误和资源浪费。
如果使用三次握手，就算那一次失效的报文传输过来，服务器接受了那一条失效报文，并且回复了确认报文，但是客户端不会再次发出确认，由于服务器接收不到确认，就知道客户端没有请求连接。

### 4.11 四次挥手的时候为什么要等待2ms

虽然四个报文发送结束以后我们就可以直接进入close状态了，但是我们必须假设网络的不可靠，有可能最后一个ACK丢失，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文，在客户端发送出最后的ACK请求时，但是该ACK可能丢失，服务器如果没有收到ACK时，将不断地发送FIN片段，所以客户端不能马上结束。他必须确认了服务器接收到了该ACK才能进入到TIME_WAIT状态。客户端会设置一个计时器，等待2msl的时间，如果该时间内再次收到了FIN包，那么客户端会再次启动计时器等到2MSL内，客户端没有收到FIN，那么客户端推断ACK已经成功被接受，则结束TCP连接。

### 4.12 为什么连接的时候是三次握手而关闭的时候是四次挥手？

因为当服务端接收到客户端的SYN连接请求的时候，可以直接发送SYN+ACK报文，其中SYN报文是用来同步的，ACK报文是用来应答的。但是关闭连接的时候，当服务器端接收到FIN报文时，很可能不会立即关闭SOCKET,所以只能回复一个ACK报文，告诉客户端，“你发送的FIN报文我已经收到了”，只有等我服务器端所有的报文发送完毕之后，我才能发送FIN报文，因此不能一起发送，故需要四次握手。

### 4.14如果已经建立了连接，但是客户端突然出现了故障怎么办？

TCP还有一个保活计时器，显然客户端如果出现了故障，服务器不能一直等下去，浪费资源，服务器每收到一次客户端的请求都会重新恢复这个计数器，时间通常设置为2小时，如果两个小时没有收到任何客户端的数据，服务器就会发送一个探测文段，以后每隔75s发送一次，若一连发送十次都没有反应，服务器就会认为客户端故障，接着就关闭了连接。