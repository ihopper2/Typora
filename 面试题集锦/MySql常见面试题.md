## 1.数据库基础知识

### 1.1 为什么要使用数据库

- 数据库可以永久保存
- 使用Sql语句，查询效率方便效率高
- 管理数据方便

### 1.2 什么是SQL

结构化查询语言，是一种数据库查询语言

作用主要是：存取数据，更新和管理关系数据库

### 1.3 数据库三大范式

第一范式：每个列都是不可再拆分的。

第二范wo式：在第一范式的基础上，非主键列都完全依赖主键列，不能依赖一部分。

第三范式：在第二范式的基础上，非主键列只能依赖主键，不能依赖其他的非主键。

我们在设计数据的时，要尽量依赖这三范式，如果不遵守，则必须要有足够的理由，比如性能。

### 1.4 mysql有关权限的表有哪几个？

MySQL服务器通过权限表来控制用户对于数据库的访问，权限表存放在mysql数据库里面，又mysql_install_db脚本初始化。这些权限表分别是user，db，table_priv，columns_priv和host。下面介绍这些表的结构和内容：

user权限表：记录可以连接数据库用户账号信息。

db权限表：记录各个账号在各个数据库上操作权限。

table_priv权限表:记录数据库表级操作。

columns_priv权限表：记录数据列级别操作。

host权限表：配合db权限表对给定主机上数据库操作权限做出更细致控制。

### 1.5 数据类型

|       分类       |   类型名称   |               说明                |
| :--------------: | :----------: | :-------------------------------: |
|     整数类型     |   tinyint    |      很小的整数（8位二进制）      |
|                  |   smallint   |      小的整数（16位二进制）       |
|                  |  mediumint   |    中等大小整数（24位二进制）     |
|                  |     int      |    普通大小整数（32位二进制）     |
|     小数类型     |    float     |           单精度浮点数            |
|                  |    double    |           双精度浮点数            |
|                  | decimal(m,d) |         压缩严格的定点数          |
|     日期类型     |     year     |         YYYY    1901-2155         |
|                  |     time     |             HH:MM:SS              |
|                  |     date     |            YYYY-MM-DD             |
|                  |   datetime   |        YYYY-MM-DD HH:MM:SS        |
|                  |  timestamp   |        YYYY-MM-DD HH:MM:SS        |
| 文本、二进制类型 |   CHAR(M)    |         M为0~255之间整数          |
|                  |  VARCHAR(M)  |       M为0~65535之间的整数        |
|                  |   TINYBLOG   |         允许长度0~255字节         |
|                  |     BLOG     |        允许长度0~65535字节        |
|                  |  MEDIUMBLOG  |      允许长度0~167772150字节      |
|                  |   LONGBLOG   |     允许长度0~4294967295字节      |
|                  |   TINYTEXT   |         允许长度0~255字节         |
|                  |     TEXT     |        允许长度0~65535字节        |
|                  |  MEDIUMTEXT  |      允许长度0~167772150字节      |
|                  |   LONGTEXT   |     允许长度0~4294967295字节      |
|                  | VARBINARY(M) | 允许长度0~M个字节的变长字节字符串 |
|                  |  BINARY(M)   | 允许长度0~M个字节的定长字节字符串 |

- 整数类型：分别表示1字节，2字节，3字节，4字节整数，任何整数类型前面都可以加上UNSIGNED属性，表示是无符号数。
  - 整数类型可以指定长度，例如int(11),表示长度为11的int类型，长度在大多数场景中没有意义的，他不会限制数值的合法范围，只会影响字符的显示个数。而且需要和UNSINGED配合才有意义。
  - int(5)    12   数据库实际插入00012
- 实数类型：float double decimal
- 字符串类型 varchar char text blog
  - varchar用于存储可变长度的字符串，他比定长类型char更节省空间，但是需要额外使用一个或者两个字节来存储字符串长度。
  - varchar存储的内容长度超过限制的时候会被**截断**
  - char会根据需要使用空格填充进行比较
  - char适合存储很短的字符串，或者所有值都接近同一个长度
  - char长度超过限制也会被截断
  - 尽量不要使用TEXT/BLOG，查询时会使用临时表，胆汁性能开销
- 时间类型：尽量使用timestamp，空间效率高于datetime

## 2.存储引擎

### 2.1 定义

存储引擎：mysql中的数据、索引和以及其他对象时如何存储的，是一套文件系统的实现

常见的存储引擎：

- Innodb引擎：提高了对于事务的支持，而且支持行级锁和外键
- MyIASM引擎：不同高事务支持，也不支持行级锁和外键
- MEMOR引擎：所有数据存储在内存中，数据处理极快，但是安全性不高。

### 2.2 MyISAM和InnoDB索引的区别：

- InnoDB索引是聚簇索引，MyISAM是非聚簇索引

- InnoDB索引的叶子节点存储着**行数据**，因此主键索引非常高效。

- MyISAM索引的叶子节点存储的是行数据地址，因此要在寻址一次才能得到数据。

- InnoDB非主键的叶子节点存储的是主键和其他带索引的列数据，因此查询时覆盖索引非常高效。

### 2.3 InnoDB引擎的四大特性：

插入缓冲

二次写

自适应哈希索引

预读

## 3.索引

### 3.1 定义

索引是一种特殊的数据结构，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。索引的实现通常是B树或者B+树。

### 3.2 索引的优点和缺点

优点

- 可以大大加快检索速度
- 可以在查询时使用**优化隐藏器**，提高系统性能。

缺点：

- 时间方面：创建索引时需要消耗时间，具体地，当对表中增减，修改数据时，也要对索引进行修改。
- 空间方面：索引也需要占据物理空间。

### 3.3 索引使用场景

where ：是否对查询字段建立索引，sql地执行效率明显不同。

order by：将查询结果按照某个字段排序地时候，如果该字段没有建立索引，那么执行计划会将查询出地所有数据使用外部排序，这个很影响性能。

join on：对于join on涉及地字段建立索引可以提高执行效率。

覆盖索引：如果对于要查询地字段建立索引，那么引擎就会直接在索引表中查询而不会访问原始数据。这就时索引覆盖。

### 3.4 索引有哪几种类型

**主键索引：**数据列不允许重复，也不允许有null值，一个表只能有一个主键。

**唯一索引：**数据列不允许重复，但是可以有null值，一个表允许有多个列创建唯一索引。

alter table table_name add UNIQUE(column1,column2,...)

**普通索引：**数据列允许重复，也可以有null值

alter table table_name add index (column1,column2,...)

**全文索引：**目前搜索引擎地一种关键技术

### 3.5 索引数据结构

索引得数据结构和存储引擎有关，常见得索引数据结构有B+树和hash，而我们使用得MySQL默认的存储引擎InnoDB使用的是B+树。

对于哈希索引来说，底层数据结构就是哈希表，对于查找单条记录，可以选择哈希索引，其余大部分使用B+树。

B+树索引

查询方式：

主键索引区：（关联保存数据的地址），按照主键查询

普通索引区：（关联id地址，然后在到达上面的地址），所以按照主键查询最快

B+性质：

n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。

所有叶子节点中包含全部关键字信息，以及指向这些关键字的记录的指针，且叶子节点本身依赖关键字的大小自小而大顺序排列。

所有非终端节点可以看作索引部分，节点中仅仅包含其子树的最大或者最小关键字。

B+树，数据的插入和删除仅仅在叶子节点中进行。

B+树有2个指针，一个是树的根节点，一个是最小关键码的叶子节点。

哈希索引：

类似于数据结构中简单实现的HASH表（散列表）一样

### 3.6 索引的基本原理

索引是用来寻找那些具有特定价值的记录。如果没有索引就会执行整张表的查询。

索引的原理很简单，就是把无序的数据变成有序的查询。

- 把创建索引的列的内容进行排序。
- 对排序结果生成倒排表。
- 在到排表内容上拼上数据地址链。
- 在查询的时候，先拿到倒排表内容，在取出数据地址链，从而拿到具体数据。

### 3.7 常见的索引算法

#### Btree算法

Btree算法是mysql数据库索引算法，它不仅仅可以用在= > < >=  <=和between这些比较操作符上，还可以用在like操作符，只要是他的查询条件不是以一个通配符%开头的常量。

#### Hash算法

Hash Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像	BTree索引需要从根节点到叶子节点，检索效率更高于BTree索引。

### 3.8索引设计的原则

- 适合索引的列出现在where子句中，或者连接子句中指定的列。
- 基数小的类，索引效果差，没有必要在此列创建索引。
- 使用短索引指向长索引。
- 不要过度索引，因为索引需要额外的空间，并降低写的操作性能。

### 3.9 索引创建的原则（重点）

- 最左前缀匹配原则
- 比较频繁作为查询条件的列创建索引
- 更新频繁的列不适合创建索引。
- 尽量做扩展索引而不是创建新的索引（增加空间开销）
- 定义有外键的列一定要创建索引
- 对于那些查询中很少涉及的列，没必要创建索引。
- 定义为text，blog，image数据类型的列不必创建索引

### 3.10 索引创建的三种方式

- 创建表的时候
- alter table table_name add index  index_name(column_list)
- create index index_name on table (column_list)

### 3.11 删除索引

alter table table_name drop key index_name;

### 3.12 创建索引的注意事项

- 非空字段：创建索引的列为not null
- 取离散值大的字段：说明这个列的唯一性越好
- 索引字段越小越好：

### 3.13 使用索引一定可以提高查询性能吗

通常索引查询数据比全表扫描要快，但是要注意付出的代价

- 索引需要空间来存储，也需要定期维护，每当表中数据发生变化时，索引也需要更新。这意味者每条记录的insert、delete、update将为此多付出4，5次磁盘io。因此不必要的索引反而会使查询时间变慢。
- 基于一个范围的检索，一般查询结果集小于表中记录数的30%
- 基于非唯一性索引的检索

### 3.14 百万级别或者以上的数据删除

时间主要是浪费在io上面了。

- 先要删除索引
- 删除其中数据
- 创建新的索引

### 3.15 前缀索引

语法：index(field(10)) 使用字段的前10个字符建立索引，默认是使用字段的全部内容建立索引

### 3.16 B树和B+树区别

- 在B树中，可以将键和值存放到内部节点和叶子节点。

- 在B+树中，内部节点都是键没有值，叶子节点存放键和值。

- B+树的叶子节点有一条链相连，而B树的叶子节点相互独立。

![B树和B+树示意图](https://img10.360buyimg.com/ddimg/jfs/t1/190674/36/17174/210809/610d0a39Edb48bf30/38f808e580ccbcee.png)

### 3.17 使用B树的好处

B树可以在内部节点同时存储键和值，因此把频繁访问的数据放在靠近根节点地方将会大大提升热点数据查询效率，这种特性使得B树在特定数据重复多次查询的场景中更加高效。

### 3.18 使用B+树的好处

由于B+树的内部节点中只存放键不存放值，因此一次读取，可以获取内存页中更多的键，有利于更快的缩小查询范围。B+树的叶子节点有一条链相连接，我们只需要花费logN的时间找到最小节点，然后她通过O(N)的时间顺序遍历即可。而B树却需要逐层遍历，这样需要更多的内存置换次数，因此也就需要花费更多的时间。

### 3.19 Hash索引和B+树的区别或者说是优劣？

Hash索引的底层是hash表，进行查找时，调用一次hash函数就可以获得相应的键值，之后进行回表查找到真实数据。B+树是现实多路平衡查找，对于每一次查找都是从根节点出发，查找到叶子节点就可以获得所查找的键值对，然后根据查询判断是否需要徽标查询数据。

- hash索引可以进行等值查询更快，但是无法进行范围查询。（因为经过hash函数之后，索引顺序无法与原来顺序表一致）。
- hash索引不支持模糊查询。
- hash索引不可避免回表查询。而B+树则是可以在某些条件下实现（覆盖索引）索引查询。
- hash索引虽然在等值上查询比较快，但是不稳定，性能不可预测。当某个键值对大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树性能稳定，对于所有的查询都是从根节点到叶子节点结束。

总结：查找速度，范围查询，性能稳定。

### 3.20 数据库为什么使用B+树而不是B树

- B树只适合随即检索，而B+树适合随机检索和顺序检索。
- B+树空间利用率更高，可以减少IO次数，磁盘读写次数更少。因为索引本身也是很大的，不可能全部放到内存中，也是以索引文件的形式存放在磁盘中，这样的话索引的查找过程就要产生磁盘IO。B+树的内部节点没有指向关键字的具体信息的指针，只是作为索引使用，其内部节点比B树小，可以存放更多的关键字，相对的IO次数就会减少。而IO次数正是影响索引体验的关键因素。
- B+树的查询效率更加稳定。B树的搜索有可能在非叶子节点结束，越靠近根节点查询时间越短。而在B+树中，任何关键字的查询都要从根节点走到叶子节点，所有关键字的路程都一样，导致每一个关键字的查询效率相同。
- B+树在提高了磁盘IO性能的同时并没有导致元素遍历的效率低下，B+树的叶子节点使用指针顺序的串联起来，只要遍历叶子节点就能实现整棵树的遍历。而数据库针对于范围的查询非常普遍，但是B树不支持这种操作。
- 增删文件效率高。

总结：检索样式多，空间利用率高，查询稳定，遍历效率高，快速增删文件。

### 3.21 什么时聚簇索引？何时使用聚簇索引与非聚簇索引？

- 聚簇索引：将数据存储和索引放到一起，找到索引也就找到了数据。
- 非聚簇索引：将数据和索引分开放置，索引的叶子节点指向数据的对应行。myisam通过key_buffer先把索引缓存到内存中，当需要访问数据的时候，在内存中直接搜索索引，通过索引查找到磁盘中对应的数据，这也就是为什么索引不是key_buffer命中的时候，速度非常慢的原因。

澄清一个概念，innodb中，在聚簇索引基础之上创建的索引都是辅助索引，辅助索引访问数据都需要二次查找。非聚簇索引都是辅助索引，像复合索引、唯一索引、辅助索引叶子节点存储不是是行的物理地址而是主键值。

### 3.22 B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？

在B+树索引中，叶子节点可能存储的是当前的key值，也可能存储了当前key值以及整行的数据，这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则找一个唯一键建立聚簇索引。如果没有唯一键在，则隐士的生成一个键来成立聚簇索引。

当使用聚簇索引的时候，在对应的叶子节点，就可以获取到整行的数据，因此不需要回表查询。

### 3.23 非聚簇索引一定要回表查询吗？

不一定，这涉及到查询语句所要求的字段是否命中了全部索引，如果命中了，则不需要。

select age from people where age  < 20; 包含了age信息，就不需要回表查询。

### 3.24 联合索引是什么？

Mysql可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段挨个使用，否则无法命中索引。

### 3.25 索引失效

全职匹配我最爱，最左前缀要遵守；

带头大哥不能死，中间兄弟不能断；

索引上面少计算，范围后面都失效；

like%写最右，覆盖索引不写星；

不等空值还有or，索引失效要少用。

## 4.事务

### 4.1 什么是事务

事务时一个不可分割数据库操作序列。

### 4.2 事务的四大特性

- 原子性：事务的操作要么都成功，要么都失败。
- 一致性：执行事务前后，数据保持一致。
- 隔离性：多个事务同时操作，互相不影响。
- 永久性：一个事务提交之后，他对数据库的数据的改变是永久的。

### 4.3脏读 幻读 不可重复读

- **脏读：**一个事务读取到了另一个未提交事务修改的数据，如果B回滚，那么A会错误。

- **不可重复读：**A事务读取到B事务提交修改的数据**

- **幻读：**A事务读取到B事务添加的数据

  **事务隔离级别**

  |                                                              | 脏读 | 不可重复读 | 幻读 |
  | :----------------------------------------------------------- | :--: | :--------: | :--: |
  | read_uncommitted(读未提交)   允许读取尚未提交的数据          |  x   |     x      |  x   |
  | read_committed(读已提交)        允许读取事务已经提交的数据   |  √   |     x      |  x   |
  | repeatable_read(可重复读)         对同一个字段多次读取的结果都一致除非数据本身被修改 |  √   |     √      |  x   |
  | serializable（可串行化）             对所有事务一次执行，可以防止事务之间产生干扰。 |  √   |     √      |  √   |

  Mysql默认的隔离级别是**可重复读**

事务的隔离机制实现是基于锁机制和并发调度，通过保存旧版本信心来支持并发一致性和会滚等特性。

InnoDB存储引擎在**分布式事务**的情况下采用可串行化隔离级别。

## 5. 锁

### 5.1 按照锁的粒度来分数据库锁有哪些？锁机制和InnoDB算法

在关系型数据库中，可以按照锁的粒度分为行级锁、表锁和页锁。

MyISAM采用表级锁

InnoDB支持行级锁和表级锁。

- **行级锁：**是Mysql中锁的粒度最细的，表示只针对当前操作进行加锁。行级锁大大减少了数据库的冲突。分为：共享锁和排他锁。
  - 特定：开销大，加锁慢，会出现死锁；锁定力度最小，发生锁的冲突概率最小，并发度最高。
- **表级锁：**是Mysql中锁粒度最大的，表示对于当前操作的整张表加锁。实现简单，资源消耗少。分为：共享读锁（共享锁）和表独占锁（排他锁）。
  - 特点：开销小，加锁快，不会出现死锁；锁定力度大，发生锁冲突概率大，并发度低。
- **页锁：**是介于行及锁和表级锁之间的一种锁。一次锁定一组相邻的数据。

### 5.2 锁的类别

共享锁（读锁）：当用户要读取数据的时候，加上读锁。共享锁可以加多个。

排他锁（写锁）：当用户要写入数据的时候，加上写锁，写锁只可以加一个。这个和其他的读锁和写锁都互斥。

在MyIsam中加入写锁和读锁

|               | 写加锁表                 | 读加锁表                 | 写其他表 | 读其他表 |
| ------------- | ------------------------ | ------------------------ | -------- | -------- |
| A（加入写锁） | ok                       | ok                       | no       | no       |
| B（不加锁）   | 会发生堵塞，直到锁的释放 | 会发生堵塞，直到锁的释放 | ok       | ok       |
|               |                          |                          |          |          |
| A（加入读锁） | no                       | ok                       | no       | no       |
| B（不加锁）   | 会发生堵塞，直到锁的释放 | ok                       | ok       | ok       |



### 5.3 死锁

死锁：是指多个事务在同一个资源上相互占用，并请求锁定对方资源，从而导致恶行循环。

解决方法：

- 多个程序并发读取多个表，尽量按照相同的顺序访问表，可以大大降低死锁概率。
- 在一个事务中，尽量一次锁定所有的资源，减少死锁概率的产生。
- 对于易发生死锁的业务部分，可以尝试升级锁定颗粒度，通过表级锁减少死锁的概率产生。

### 5.4 数据的乐观锁和悲观锁

- 悲观锁：认为一定会发生冲突，屏蔽一切可能违反数据完整性的操作，在查询数据的时候把事务锁起来，直到提交事务；
  - 实现方式：使用数据库中的锁。
  - 使用场景：写较多的时候。

- 乐观锁：认为不会发生冲突，只是在修改数据的时候把事务锁起来，通过version的方式进行锁定。
  - 实现方式：版本号和CAS算法。
  - 使用场景：读较多的场景。

## 6.视图

### 6.1 为什么要使用视图

为了提高复杂SQL语句的复用性和表操作的安全性，实质是一种虚拟表，在物理上上不存在的，其内容与真实表相似。包含了一系列带有名称的列和行数据。

### 6.2 视图特点

- 视图的列可以来自不同的表
- 视图是由实表产生的虚表
- 视图的建立和删除不影响虚表
- 对视图的内容进行跟新，影响基本表。
- 当视图来自多个表时，不能进行添加和删除数据。

### 6.3 使用视图的场景

- 重用SQL。
- 简化复杂的SQL操作。
- 使用表的组成部分而不是整个表。
- 保护数据。

### 6.4 视图优点

- 查询简化，视图可以简化用户操作。
- 数据安全，视图可以使用户能以多种角度看待同一数据，能够对机密数据提供安全保护。
- 逻辑数据独立性，视图对重构数据库提供了一定程度的逻辑独立性。

### 6.5 视图缺点

- 性能，数据库必须把对视图的查询转化成对于基本表的查询，如果视图是由一个复杂的多表查询，需要花费较多的时间。
- 修改限制，多个表创建的视图，不能修改。

### 6.6游标

游标是系统为用户开设的一个**数据缓冲区**，存放SQL语句的执行结果。

## 7.存储过程与存储函数

### 7.1什么是存储过程

就是一个预编译的sql语句，只需要创建一次，以后在程序中多次调用就可以了。

优点：

- 存储过程时预编译过的，效率高。
- 存储过程直接放到数据库中，通过存储过程名直接调用。
- 安全性高，需要一定权限的用户调用。
- 存储过程可以重复使用，减少数据库开发人员的工作量。

缺点：

- 调试麻烦
- 维护麻烦

## 8.触发器

触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。**触发器是指一段代码，当触发某个事件时，自动执行这些代码。**

### 8.1 Mysql中的触发器

Before Insert

After Insert

Before Update

After Update

Before Delete

After Delete

## 9.常用SQL语句

### 9.1 sql语句分为哪几类

数据库定义语言 DDL create、drop、alter

数据库查询语言DQL select

数据库操作语言 DML insert、update、delete

数据库控制语言DCL grant revoke commit rollback

### 9.2 超键、侯主键、主键、外键分别是什么

- 超键：在关系中能唯一标识元组的属性集称为关系模式的超键
- 侯主键：最小的超键
- 主键：可以对数据库表中存储对象予以唯一标识和完整标识的数据列或属性集合。一个数据列只可以有一个主键，不能为null和不能重复。
- 外键：在一个表中存在另一个表的主键称为此表的外键

### 9.3 SQL约束

- not null
- unique
- primary key
- foreign key
- check

### 9.4 六种关联查询

- 交叉连接

- 内连接
  - 等值连接 ON A.id=B.id
  - 不等值连接 ON A.id>B.id
- 外连接
  - 左外连接
  - 右外连接 
- 联合查询
- 全连接

### 9.5 子查询

条件：一条SQL语句的查询结果作为以一个查询语句的条件或者结果

嵌套：多条语句嵌套使用，内部的SQL语句称为子查询

### 9.6 mysql中的in 和exists区别

mysql语句中的in把外表和内表做hash连接，而exists语句是对外表做loop循环。

- 如果两个表大小相当，in和exists相差不大。
- 如果一个大表一个小表，则子查询大表使用exists，而子查询小表使用in。
- not in和not exists：使用not exists还可以使用索引。

### 9.7 varchar和char区别

- char固定长度，插入数据小于固定长度，使用空格填充，属于空间换时间的做法。
- varchar可变字符，插入多少，存储多少，属于时间换空间。

#### varchar(50)含义

最多放50个字节 varchar20 和varchar50中hello所占的字符数一样。

#### int(20)含义

是指显示长度为20 int(5) 00012

### 9.8 float和double区别

float最多存储8位十进制数，在内存中占据4个字节

double最多存储18位十进制数，在内存中占据8字节

### 9.9 drop truncate delete区别

|          | DELETE                               | Truncate                     | Drop                           |
| -------- | ------------------------------------ | ---------------------------- | ------------------------------ |
| 类型     | DML                                  | DDL                          | DDL                            |
| 回滚     | 可以                                 | 不可以                       | 不可以                         |
| 删除内容 | 表结构还在，删除表的全部或者部分数据 | 表结构还在，删除表的全部内容 | 删除表结构，索引、权限也会删除 |
| 删除速度 | 最慢                                 | 较快                         | 最快                           |

总结：在不需要一张表的时候drop，删除表的全部内容：truncate；删除部分表内容：delete



## 10.SQL优化  

### 10.1 如何定位几优化SQL语句的性能的问题？创建的索引有没有被使用到？

对于低性能sql语句的定位，最重要也是最有效的方法就是使用执行计划，Mysql提供了explain命令来查看语句的执行计划。

对于查询语言最重要的就是使用索引。

| id   | select_type | table | type | possible_keys | key  | key  | len  | ref  | row  | extra |
| ---- | ----------- | ----- | ---- | ------------- | ---- | ---- | ---- | ---- | ---- | ----- |

#### id（查询序号）

- 表示语句的执行顺序
- id不同，数字大的先执行
- id相同，从上往下执行

#### select_type（每个子查询的查询类型）

- simple      不包子查询
- primary    包含子查询，最外面的显示为primary
- subquery 当子查询在where字段中
- derived     子查询在from中
- union         union后面的查询语句
- union result    从union中获取结果集

#### table（查询的数据表）

#### type（非常重要可以看到有没有使用索引）访问类型

- all 全表扫描
- index 遍历索引
- range 索引范围查找
- ref 
- eq_ref  常见于主键或者唯一索引
- const  通过索引一次就找到了
- system表中只有一行记录

最少达到range，能达到ref就好了

#### possible_keys 可能使用的索引，不一定会使用到

#### key 查询中实际使用的索引

#### key_len 索引长度

#### ref 索引的哪一列被使用了

#### row 找到结果所需要读取的行数

#### extra 额外信息

- using index 使用索引覆盖
- using where 使用where自己来过滤结果集
- using filesort 使用了外部排序，不是使用索引的内部排序
- using tempoary 使用了临时表保存中间结果

### 10.2 SQL的生命周期

- 应用服务器与数据库服务器建立一个连接
- 数据库进程拿到请求sql
- 解析并生成执行计划，执行
- 读取数据到内存并进行逻辑处理
- 通过步骤一连，发送结果到客户端
- 关闭连接，释放资源

### 10.3 大表数据查询，怎么优化

- 使用索引
- 加缓存，redis
- 主从复制，读写分离

### 10.4 超大分页怎么解决

- 数据库层面希望使用到索引
- 从需求减少的角度，不做类似的功能，子允许逐页查询或者按照既定的路线走，依靠缓存

### 10.5 慢日志查询

用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。

开启：set global slow_query_log = on

查看是否开启：show variables like 'slow_query_log'

设置临界时间：set long_query_time=0.5

查看日志，一旦超过了临界时间，记录到日志中

### 10.6 如何对慢查询进行优化

- 分析语句，看看是否load额外的数据，有多余的就去掉。
- 分析预计执行计划，看看索引的使用情况；进行索引的修改。
- 如果语句优化到位，看看是不是数据量过大，如果是的话，可以进行横向或者纵向切表。

### 10.7 为什么要设置一个主键

主键使确保数据行在数据库唯一性的保障，即使业务上本张表没有主主键，我们也要设置一个主键。

### 10.8 主键使用自增id还是uuid

建议使用自增id。

因为在InnoDB存储引擎中，主键使作为聚簇索引存在的，也就是说主键索引的B+树叶子节点上存储了主键索引以及全部数据。如果主键id使自增的，那么只需要不断地向后排列就可以了。如果使uuid，由于原来的ID与进来的ID大小不确定，还需要排序，会造成很多的插入，数据移动，导致很多内存碎片的产生。造成性能的下降。

关于主键使聚簇索引，如果没有主键，会默认一个唯一索引位聚簇索引，如果没有唯一键，会隐式生成一个主键。

### 10.9 字段为啥要求为 not null

因为null会占据更多字节。会造成程序中很多和预期不符合。

### 10.10 如果要存储用户的密码散列，因该使用什么字段存储？

密码散列，盐，用户省份证使用固定长度的字符串，使用char而不是varchar，这样可以节省空间。

### 10.11 优化关联查询

- 确定ON或者USING句子中有索引
- 确定GROUP BY和ORDER BY中只有表中一个列，这样MYSQL才有可能使用索引。

### 10.12 SQL语句的优化方法

- 对查询进行优化，尽量避免全表扫描，首先考虑在where、group by和order by涉及的列上建立索引。
- 尽量避免在where子句中对字段进行null判断，这样会导致放弃使用索引，变成全表扫描。
- 尽量避免使用不等号判断
- 尽量避免使用or、in和not in判断
- 不要在where中使用参数，计算

### 10.13 order by关键字优化

- 关键字索引化
- 在索引上完成排序

## 11.数据库优化

### 11.1 为什么要优化

系统的吞吐量瓶颈往往是出现在数据库的访问速度上面。

程序的运行，数据库中数据量增加，会导致查询变慢。

数据库存放在磁盘中，读写速度和内存无法比。

### 11.2 数据库结构优化

将字段多的表拆成多个表。

增加中间表

适量增加冗余。

### 11.3 Mysql数据库cpu飙升到500%的话怎么处理？

- top命令看看是不是mysqld占用导致的
- 如果是，使用show processlist，看看里面的session情况，找出消耗高的sql
- 然后kill对应的线程。
- 如果要是因为大量的连接进来导致的，那就限制一下连接数目。

### 11.4 当mysql单表的数据量过大，数据库的crud性能明显下降，常见的优化措施

**限定数据的范围：**无比禁止任何不带限制数据范围的查询；比如当我们查询用户的历史订单的时候，限定在一个月内。

**读写分离：**主库负责写，从库负责读。

**缓存：**对于常使用的数据，进行缓存。

**通过分库分表的：**垂直分表和水平分表。

### 11.5 MYSQL的复制原理以及流程

主从复制：将主数据库的DDL和DML操作通过二进制文件传输到从数据库中，然后将这些日志重新执行，从而使得主从数据库数据保持一致。

#### 主从复制作用

- 主数据库出现问题使用从数据库
- 可以进行数据库层面的读写分离
- 可以从数据库上进行备份

### 11.6 数据库如何备份

100G以内使用mysqldump，在业务低峰的时候备份

100G以上使用xtranback，一周一个全备，每天增量备份

### 11.7 数据库表的修复

使用myisamchk来修复

- 停止数据库服务
- 进入到数据库的表bin目录
- 执行myisamchk -recover命令







